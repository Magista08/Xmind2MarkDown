<center><h1>C/C++
编码规范</h1></center>
[TOC]
<div STYLE="page-break-after: always;"></div>
## 1 通用原则
### 1.1 简单原则（KISS）
尽量以初学者可以理解和掌握的方式编写代码，严禁耍酷炫技
从跨平台支持和可维护性出发，缺省以C99和C++11为编译标准
尽量以C语言为基础编写代码，同时辅以C++的面向对象特性
慎用RTTI、模板和异常等初学者不易理解和掌握的C++语言特性
仅当可有效简化代码时才考虑使用C99和C++11引入的新特性
### 1.2 易理解原则
- 在C/C++语法基础上施加额外约束，在不影响功能实现的前提下提高代码质量与可读性
示例：强制用大括号{}包围所有分支与循环代码块
- 通过人为约定内部命名与编码规则，在基础代码层面帮助理解代码和发现缺陷
示例：匈牙利命名规则
示例：强制“this->”或“类名::”方式调用本类方法
示例：全局函数、公开类方法、非公开类方法分别使用下划线分隔、开头大写驼峰、开头小写驼峰的不同命名规则；保证每个模块的至少统一，或者是一个人写的代码必须统一
- 通过空格插入、代码缩进和上下对齐等规范，在基础代码层面帮助理解代码和发现缺陷
示例：相关代码尽量上下对齐
示例：相关命名尽量相同长度
### 1.3 可移植原则
使用C/C++标准语法，慎用gcc和msc的专有特性（无法避免时使用条件编译）
使用C/C++标准库，慎用平台相关的接口与功能（无法避免时提供平台隔离层）
利用“__cplusplus”宏和“extern C”语法等特性实现C和C++代码的相互兼容
在代码少和可移植冲突时优先考虑可移植特性
### 1.4 性能优先原则
选用C/C++技术栈多为提升性能，因此在代码少、易理解与高性能冲突时优先考虑性能
## 2 强制规范
### 2.1 目录
- 原则
每个目录实现特定用途
各个目录内不保存无关文件
- 命名
一般为1~3个单词的名词短语
单词小写+下划线分隔 (示例：a_demo_dir)
缩写词大写 (示例：a_SCADA_dir)
- 结构
	- 单个组件的目录结构
![强制规范-目录-结构-组件](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-目录-结构-组件.png)
	说明：组件被工具或应用共享，一般以DLL形式存在
	- 单个工具的目录结构
![强制规范-目录-结构-工具](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-目录-结构-工具.png)
	说明：工具在内部使用，不向最终用户发布，一般以EXE形式存在
	- 单个应用的目录结构
![强制规范-目录-结构-应用](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-目录-结构-应用.png)
	说明：应用向最终用户发布并被其使用，一般以EXE形式存在
- 注释
必要时提供“README.txt”描述目录与特定文件用途
### 2.2 文件
- 原则
每个文件用于特定用途（避免单个文件完成过多功能）
- 命名
一般为1~3个单词的名词短语
	- 文件后缀
		- 头文件 = xxx.h（小写后缀）
		禁止：*.hpp *.hxx
		禁止：任意后缀字符大写
		- C实现文件 = *.c（小写后缀）
		禁止：任意后缀字符大写
		- C++实现文件 ＝ *.cpp（小写后缀）
		禁止：*.cc *.cxx
		禁止：任意后缀字符大写
	- 类文件命名
	等于类名的名词短语 (示例：FileManager.cpp)
	开头大写+大小写分隔 (示例：FileManager.cpp)
	非尾缩写词首字母大写 (示例：EmsInterface.cpp, ParkEms.cpp 或 ParkEMS.cpp)
	- 非类文件命名
	描述功能的名词短语 (示例：cmnUtils.cpp)
	开头小写+大小写分隔 (示例：cmnUtils.cpp)
	头部缩写词全小写，非尾缩写词首字母大写 (示例：emsUtils.cpp, someEmsUtils.cpp, ParkEms.cpp 或 ParkEMS.cpp)
- 内容
文件编码必须为UTF-8
文件换行必须为UNIX格式（\n）
文件必须以单个空行开头
文件必须以单个空行结尾
文件必须行尾去空白保存
	- 头文件（.h）
		- 模板
![强制规范-文件-内容-头文件]F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-文件-内容-头文件.png}
		示例
![强制规范-文件-内容-示例]{F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-文件-内容-示例}
	- 实现文件（.c/cpp）
		- 模板
![强制规范-文件-内容-实现文件](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-文件-内容-实现文件.png)
		示例
![强制规范-文件-内容-实现文件-模板](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-文件-内容-实现文件-模板.png)
- 注释
	- 文件级注释模板
![强制规范-文件-内容-注释](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-文件-内容-注释.png)
	模板适用于doxygen文档格式
	注意注释元素（file/author/date/brief/...）的顺序
### 2.3 指令
- 包含（#include）
	- 原则
	只包含必须包含的头文件
		- 标准头文件用<>包围，组织公共头文件和项目内部头文件用""包围
![强制规范-指令-包含-原则-标准](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-指令-包含-原则-标准.png)
		注意：不同于编译器对<>和""的处理方式
		- 三类头文件（标准头文件，组织公共头文件，项目内部头文件）按顺序包含
![强制规范-指令-包含-原则-三类](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-指令-包含-原则-三类.png)
	- 结构
		- 头文件（.h）
			- 不包含非必需头文件
			说明：头文件经常被其它头文件包含，不必要的包含导致连锁依赖，严重影响编译速度
		动态库的定义文件“export.h”应该在本地（LOCAL）区的第1个包含
![强制规范-指令-包含-结构](F:\Internships\Internship_ShanghaiElectric\c++编码规范\\强制规范-指令-包含-结构.png)
		- 实现文件（.c/cpp）
			- 不包含非必需头文件
			说明：头文件经常包含其它头文件，不必要的包含导致连锁依赖，严重影响编译速度
![强制规范-指令-包含-实现文件](F:\Internships\Internship_ShanghaiElectric\c++编码规范\强制规范-指令-包含-实现文件.png)
	- 注释
		- 每个包含指令末尾附加依赖注释
			示例
```c++
			#include <stdio.h> /* FOR: printf */
```
		- 头文件中的依赖注释必须使用C注释语法/*...*/
			示例
```c++
			=== demo/func01.h ===
			#include <stdio.h> /* FOR: printf */
```
		- 实现文件中的依赖注释由文件类型（C或C++）决定
			示例
```c++
			=== xxx.c ===
			#include <stdio.h> /* FOR: printf */
			

			=== xxx.cpp ===
			#include <stdio.h> // FOR: printf
```
- 宏（#define）
	- 原则
		- 只在必要时使用宏定义
			- 定义常量
				示例
```c++
				#define PI 3.1416 /*! 圆周率π */
```
			- 简化代码
				示例
```c++
				#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0])) /*! 数组元素数量 */
```
			- 条件编译
				示例
```c++
				/*! 函数参数缺省值 */
				#ifdef __cplusplus
				    #define DEFAULT_PARAM_VALUE(value) = value
				#else
				    #define DEFAULT_PARAM_VALUE(value)
				#endif/*__cplusplus*/
```
		- 合适场景使用替代方案
		使用const定义常量 (const double PI = 3.1415927;)
		使用inline内联函数简化代码
		- 定义常量时，必须用括号包围多个部分（避免宏展开时因优先级导致的意外结果）
			示例
```c++
			#define PI 3.1416 -> 单个部分无需括号包围
			#define ARRAY_LENGTH (sizeof(array)/sizeof(array[0])) -> 多个部分必须括号包围
```
	- 命名
		- 单词大写+下划线分隔
			示例
```c++
			#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))
```
	- 注释
		- 多个宏定义之间无空行时，使用空格分隔的行尾注释
			示例
```c++
			#define E  2.7183 /*! 自然对数e */
			#define PI 3.1416 /*! 圆周率π */
```
		- 多个宏定义之间空行分开时，使用相同缩进的前导整行注释
			示例
```c++
			/*! 自然对数e */
			#define E 2.7183
			

			/*! 圆周率π */
			#define PI 3.1416
```
		- 无论何种注释（整行注释，行内注释，行尾注释），均使用C注释语法/*...*/
		说明：同时支持C和C++文件引用
		说明：避免移植时老旧编译器不识别行尾//注释
- 条件（#if/#elif/#else）
条件代码缩进一级
	- 单个简单判断条件使用：#ifdef/#else/#endif (#ifdef DEBUG |     #define LOG_DEBUG(x) printf(x) | #else |     #define LOG_DEBUG(x) | #endif/*DEBUG*/)
		示例
```c++
		#ifdef DEBUG
		    #define LOG_DEBUG(x) printf(x)
		#else
		    #define LOG_DEBUG(x)
		#endif/*DEBUG*/
```
	- 单个复杂判断条件使用：#if/#else/#endif
		示例
```c++
		#if defined(DEBUG) || defined(VERBOSE)
		    #define LOG_DEBUG(x) printf(x)
		#else
		    #define LOG_DEBUG(x)
		#endif/*DEBUG||VERBOSE*/
```
	- 多个判断条件使用：#if/#elif/#else/#endif
		示例
```c++
		#if defined(DEBUG)
		    #define LOG_DEBUG(x) printf(x)
		#elif defined(RELEASE)
		    #define LOG_DEBUG(x)
		#else
		    #error "please define DEBUG or RELEASE"
		#endif
```
- 编译（#pragma）
	- 常用
	内存边界对齐 (#pragma pack(push, 1) |  | typedef struct T_Packet | { | 	char a; | 	short b; | 	int c; | } | T_Packet; |  | #pragma pack(pop))
	屏蔽指定警告 (=== MSC === | #pragma warning(disable:4514) | #pragma warning(disable:4819) |  | === GCC === | #pragma GCC diagnostic ignored "-Wunused-macros" | #pragma GCC diagnostic ignored "-Wunused-parameter")
### 2.4 类型
- 常量（const）
	- 原则
	#define常量的类型由值决定，引用时就地展开
	const常量的类型需要指定，老编译器不支持
	enum常量只支持整数，便于批量定义相关常量
	- 命名
	一般为1~3个单词的名词短语
	单词大写+下划线分隔 (const int MAX_INTEGER = 0x7FFFFFFF;)
		- 常量不加类型前缀
		如：b n f s ...
		- 常量不加作用域前缀
		如：g_ f_ s_ ...
	- 注释
	多个常量定义之间无空行时，使用空格分隔的行尾注释 (const double E  = 2.7183; /* 自然对数e */ | const double PI = 3.1416; /* 圆周率π */)
	多个常量定义之间空行分开时，使用相同缩进的前导整行注释 (/* 自然对数e */ | const double E = 2.7183; |  | /* 圆周率π */ | const double PI = 3.1416;)
	- 其它
	L F D E 等定义数值后缀大写 (#define PI 3.1416F |  | const double PI = 3.1415926535D |  | #define LIGHT_SPEED 2.99792458E+8)
- 枚举（enum） (typedef enum E_PluginType | { |     PT_MYSQL  = 1 /*! MySQL数据库 */, |     PT_ORACLE = 2 /*! Oracle数据库 */ | } | E_PluginType;)
	- 原则
	多个相关整型常量应该以枚举方式统一定义
	为兼容C和C++语法，统一使用typedef形式定义 (typedef enum E_PluginType | { |     PT_MYSQL  = 1 /*! MySQL数据库 */, |     PT_ORACLE = 2 /*! Oracle数据库 */ | } | E_PluginType;)
	- 命名
		- 枚举名
		一般为1~3个单词的名词短语
		首字母大写+大小写分隔 (typedef enum E_PluginType | { |     PT_MYSQL  = 1 /*! MySQL数据库 */, |     PT_ORACLE = 2 /*! Oracle数据库 */ | } | E_PluginType;)
		全局枚举名加前缀：E_，内嵌枚举名可不加 (typedef enum E_PluginType | { |     PT_MYSQL  = 1 /*! MySQL数据库 */, |     PT_ORACLE = 2 /*! Oracle数据库 */ | } | E_PluginType;)
		- 枚举常量
		一般为1~3个单词的名词短语
		单词大写+下划线分隔 (typedef enum E_DatabaseType | { |     DT_MYSQL_V3  = 1 /*! MySQL-3.x数据库 */, |     DT_MYSQL_V4  = 2 /*! MySQL-4.x数据库 */, |     DT_MYSQL_V5  = 3 /*! MySQL-5.x数据库 */, |  |     DT_ORACLE_V8 = 4 /*! Oracle-8i数据库 */, |     ... | } | E_DatabaseType;)
		全局枚举常量加前缀，规则为枚举名去前缀的首字母缩写，内嵌枚举常量可不加 (typedef enum E_DatabaseType | { |     DT_MYSQL_V3  = 1 /*! MySQL-3.x数据库 */, |     DT_MYSQL_V4  = 2 /*! MySQL-4.x数据库 */, |     DT_MYSQL_V5  = 3 /*! MySQL-5.x数据库 */, |  |     DT_ORACLE_V8 = 4 /*! Oracle-8i数据库 */, |     ... | } | E_DatabaseType;)
	- 注释
	单行定义单个枚举时，使用行尾注释（前面及内部加空格） (typedef enum E_PluginType | { |     MYSQL  = 1 /*! MySQL数据库 */, |     ORACLE = 2 /*! Oracle数据库 */ | } | E_PluginType;)
	单行定义多个枚举时，使用行内注释（前后及内部无空格） (typedef enum E_PluginType { MYSQL = 1/*!MySQL数据库*/, ORACLE = 2/*!Oracle数据库*/ } E_PluginType;)
	隔行定义多个枚举时，使用相同缩进的前导整行注释（较少使用） (typedef enum E_PluginType | { |     /*! MySQL数据库 */ |     MYSQL = 1 , |  |     /*! Oracle数据库 */ |     ORACLE = 2  | } | E_PluginType;)
- 变量
	- 原则
	每行只定义1个变量（大量定义时可视情况同行定义） (int   nID              = 0; | char  szName[MAX_NAME] = {0}; | float fWeight          = 0.0;)
	所有全局、静态和局部变量均须显式初始化为零值或缺省值 (bool  bOK              = false; | int   nID              = 0; | float fWeight          = 0.0; | char  szName[MAX_NAME] = {0};)
	变量定义尽量靠近使用位置（新标准），也可全部定义在文件或函数开头（老标准）
	指针与引用的定义标识（*和&）与变量类型空格分隔，与变量名无空格结合 (char *pszName = NULL; | String &sAlias = sName;)
	多行变量上下对齐时忽略指针与引用标识（*和&） (int     nCount  = 0; | char   *pszName = NULL; | String  sName   = "Mike"; | String &sAlias  = sName;)
	- 命名
	一般为1~3个单词的名词短语
	首字母小写+大小写分隔 (int   nStudentID              = 0; | char  szTeacherName[MAX_NAME] = {0}; | float fCarWeight              = 0.0;)
		- 一般变量名加类型前缀（匈牙利命名法），编码模块级统一 (int   nID              = 0; | char  szName[MAX_NAME] = {0}; | float fWeight          = 0.0;)
		复合类型前缀叠加 (char *apszName[64] = {0}; -> 定义字符串(sz)指针(p)类型的数组(a) -> a + p + sz = apsz)
		类型前缀参考表 (FROM: cmn/types.h |  | /** |   the prefix of data types |  |   (1) integer |     bool                      = b |              char             = n1, c |     unsigned char             = u1 |              short            = n2 |     unsigned short            = u2 |              int              = n4, n |     unsigned int              = u4, u |              long             = n8, l |     unsigned long             = u8 |              __int64/longlong = n8, l |     unsigned __int64/longlong = u8 |  |     BYTE  = by, u1 |     WORD  = wd, u2 |     DWORD = dw, u4 |     QWORD = qw, u8 |     OWORD = ow |  |   (2) float number |     float  = f |     double = d |  |   (3) character, string |     char     = c |     char []  = sz |     char *   = psz |     string   = s |     string * = ps |  |   (4) array, pointer |     *  = p + variable prefix: pxxVar   OR simply pVar |     [] = a + variable prefix: axxVar[] OR simply aVar[] |  |   (5) STL template |     std::vector = vct |     std::list   = lst |     std::stack  = stk |     std::deque  = deq |     std::queue  = que |     std::map    = map |     std::set    = set |  |   (6) data & time |     date     = da |     time     = tm |     datetime = dt |  |   (7) Others |     enum     = e |     json     = j |     variant  = v |     function = fn |     regexp   = re | **/)
	全局变量（跨文件可访问）加前缀：g_ (int g_nCount = 0;)
	文件变量（仅文件内可访问）加前缀：f_ (int f_nCount = 0;)
	静态变量（仅函数内部可访问）加前缀：s_ (int s_nCount = 0;)
	动态变量（仅函数内部可访问）不加上述前缀 (int nCount = 0;)
	集合变量尽量使用复数形式 (int anValues[N] = {0}; | String asStudentNames[N];)
	循环变量ijk等少量惯用变量命名不受此限制
	- 结构
	连续定义3个以上变量时尽量上下对齐 (int   nID              = 0;   /* ID */ | char  szName[MAX_NAME] = {0}; /* 姓名 */ | float fWeight          = 0.0; /* 体重 */)
	带注释的代码块中，变量定义与变量使用建议用空行分隔 (/* 计算总和 */ | int nSum = 0; | （空行） | for(int i = 0; i < N; i ++) | { |     nSum += anValues[i]; | })
	- 注释
	多个变量定义之间无空行时，使用空格分隔的行尾注释 (int  nID              = 0;   /* ID */ | char szName[MAX_NAME] = {0}; /* 姓名 */)
	多个变量定义之间空行分开时，使用相同缩进的前导整行注释 (/* ID */ | int nID = 0; |  | /* 姓名 */ | char szName[MAX_NAME] = {0};)
	需要生成Doxygen注释文档时应该使用/*!...*/，行尾注释必须定义在结束符,或;之前 (int  nID              = 0   /*! ID */; | char szName[MAX_NAME] = {0} /*! 姓名 */;)
	- 其它
	L F D E 等初始数值后缀大写 (float fPi          = 3.1416F | double dPi         = 3.1415926535D | double dLightSpeed = 2.99792458E+8)
- 结构体（struct） (typedef struct T_StudentDta | { |     int  nCode; |     char szName[64]; |     int  nGrade; | } | T_StudentData;)
	- 原则
	结构体以数据为主，访问属性缺省公开，成员方法没有或很少（多为构造和析构方法）
	为兼容C和C++语法，统一使用typedef形式定义 (typedef struct T_StudentDta | { |     int  nCode; |     char szName[64]; |     int  nGrade; | } | T_StudentData;)
	- 命名
	一般为1~3个单词的名词短语
	首字母大写+大小写分隔 (typedef struct T_StudentData | { |     int  nCode; |     char szName[64]; |     int  nGrade; | } | T_StudentData;)
	全局结构体加前缀：T_，内嵌结构体可不加前缀或匿名 (typedef struct T_StudentData | { |     int  nCode; |     char szName[64]; |     int  nGrade; | } | T_StudentData;)
	成员变量命名同普通变量，不加成员前缀：m_ (typedef struct T_StudentData | { |     int  nCode; |     char szName[64]; |     int  nGrade; | } | T_StudentData;)
	- 注释
	结构体注释为前导整行注释，使用C注释语法/*...*/或/*!...*/ (/*! 学生数据集合 */ -> /*! ... */为Doxygen语法 | typedef struct T_Student | { |     int  nCode      /*! 学号 */; |     char szName[64] /*! 姓名 */; |     int  nGrade     /*! 年级 */; | } | T_Student;)
	成员变量注释请参考普通变量 (/*! 学生数据集合 */ | typedef struct T_Student | { |     int  nCode      /*! 学号 */; -> /*! ... */为Doxygen语法 |     char szName[64] /*! 姓名 */; |     int  nGrade     /*! 年级 */; | } | T_Student;)
	成员方法注释请参考普通函数
- 联合体（union） (typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	- 原则
	联合体多定义于结构体内部
	为兼容C和C++语法，统一使用typedef形式定义 (typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	- 命名
	一般为1~3个单词的名词短语
	首字母大写+大小写分隔 (typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	全局联合体加前缀：U_，内嵌联合体可不加前缀或匿名 (typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	成员变量命名同普通变量，不加成员前缀：m_ (typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	- 注释
	联合体注释为前导整行注释，使用C注释语法/*...*/或/*!...*/ (/*! 协议包数据 */ -> /*! ... */为Doxygen语法 | typedef union U_PacketData | { |     bool   bData; |     int    nData; |     float  fData; |     double dData; |     char   szData[64]; | } | U_PacketData;)
	成员变量注释请参考普通变量 (/*! 协议包数据 */ | typedef union U_PacketData | { |     bool   bData      /* 布尔型 */; -> /*! ... */为Doxygen语法 |     int    nData      /* 整型  */; |     float  fData      /* 单精度浮点型 */; |     double dData      /* 双精度浮点型 */; |     char   szData[64] /* 字符串 */; | } | U_PacketData;)
### 2.5 表达式
- 布尔比较
!只能操作布尔型，禁止操作整型等其它非布尔型
整型只能与同类型整型比较，signed与unsigned整数不能直接比较
浮点型（无论单/双精度）比较应该通过绝对差值进行 (if (fabs(fValue1 - fValue2) < EPSILON) | { |     ... | })
指针判空应该显式与NULL比较 (if (p == NULL) | { |     ... | } |  | if (p != NULL) | { |     ... | })
- 优先级
非常见优先级使用小括号进行显式保护以提高可读性 (if ((a + (b << 1) * 3) > 4))
### 2.6 结构
- if/else if/else (if (条件表达式A) | { |     /* 表达式A为真的处理 */ | } | else if (条件表达式B) | { |     /* 表达式A为假且表达式B为真的处理 */ | } | else | { |     /* 表达式A和B均为假的处理 */ | })
if/else if/else关键字各自独占一行
if/else if关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
所有处理分支缩进一级，并强制用大括号{}包围
所有“{”和“}”各自独占一行，上下对齐且不缩进
空语句必须用“/*empty*/;”显式强调
	- 最佳实践
	错误时提前退出 (=== BAD === | bool bResult = demo_func(); | if (bResult) | { |     /* 正常处理 */ | } | else | { |     /* 错误处理 */ |     return false; | } |  | === GOOD === | bool bResult = demo_func(); | if (!bResult) | { |     /* 错误处理 */ |     return false; | } |  | /* 正常处理 */)
	复杂逻辑时分级嵌套列出所有分支 (=== BAD === | if (a > 0 && b > 0) | { | 	/* a > 0 && b > 0 */ | } | else if (a > 0) | { | 	/* a > 0 && b <= 0 */ | } | else if (b > 0) | { | 	/* a <= 0 && b > 0 */ | } | else | { | 	/* a <= 0 && b <= 0 */ | } |  | === GOOD === | if (a > 0) | { |     if (b > 0) |     { |         /* a > 0 && b > 0 */ |     } |     else |     { |         /* a > 0 && b <= 0 */ |     } | } | else | { |     if (b > 0) |     { |         /* a <= 0 && b > 0 */ |     } |     else |     { |         /* a <= 0 && b <= 0 */ |     } | })
- switch/case (switch (整型表达式) | { | case 1: |     /* 表达式=1的处理 */ |     break; | case 2: |     { |         /* 表达式=2的处理 */ |     } |     break; | case 3: |     /* 表达式=3的处理 */ |     return true; | case 4: |     /* 表达式=4的处理 */ |     /* continue: XXX原因 */ | default: |     /* 表达式的缺省处理（未满足上述分支值） */ |     break; | })
switch/case/default/break关键字各自独占一行
switch关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
case关键字不缩进，case值与右侧冒号之间无空格
所有case/default分支缩进一级，存在局部变量时用大括号{}包围
所有分支必须以break或return结束，需继续至下一分支时必须用“/*原因*/”显式说明
所有“{”和“}”各自独占一行，上下对齐且不缩进
空语句必须用“/*empty*/;”显式强调
- while (while (循环条件) | { |     /* 循环体的处理 */ |  |     if (xxx) |     { |         continue; |     } |  |     if (xxx) |     { |         break; |     } |  |     /* 循环体的处理 */ | })
while/continue/break关键字各自独占一行
while关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
循环体代码缩进一级，并强制用大括号{}包围
所有“{”和“}”各自独占一行，上下对齐且不缩进
空语句必须用“/*empty*/;”显式强调
- do/while (do { |     /* 循环体的处理 */ |  |     if (xxx) |     { |         continue; |     } |  |     if (xxx) |     { |         break; |     } |  |     /* 循环体的处理 */ | } | while (循环条件))
do关键字与后面的“{”共同独占一行（共1行）
while关键字与前面的“}”各自独占一行（共2行）
while关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
continue/break关键字各自独占一行
循环体代码缩进一级，并强制用大括号{}包围
所有“{”和“}”各自独占一行且不缩进
空语句必须用“/*empty*/;”显式强调
- for (for (初始化; 循环条件; 单步循环后处理) | { |     /* 循环体的处理 */ |  |     if (xxx) |     { |         continue; |     } |  |     if (xxx) |     { |         break; |     } |  |     /* 循环体的处理 */ | })
for关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
continue/break关键字各自独占一行
循环体代码缩进一级，并强制用大括号{}包围
所有“{”和“}”各自独占一行，上下对齐且不缩进
空语句必须用“/*empty*/;”显式强调
- goto (L_xxx: |     ... |     goto L_xxx; |     ... |     goto L_yyy; |     ... | L_yyy: |     ...)
跳转标签命名：前缀L_ + （开头大写+大小写分隔）
跳转标签无缩进（第1列开始），与右侧冒号间无空格
goto关键字与跳转标签独占一行
慎用goto，仅当可有效简化代码时使用
- try/catch/finally (try | { |     /* 受保护的代码 */ | } | catch (异常1) | { |     /* 捕获异常1的代码 */ | } | catch (异常2) | { |     /* 捕获异常2的代码 */ | } | finally | { |     /* 无论正常或异常均需最后执行的代码 */ | })
try/catch/finally关键字各自独占一行
catch关键字与右侧左括号之间添加1个空格，括号表达式内侧无空格
所有处理分支缩进一级，并强制用大括号{}包围
所有“{”和“}”各自独占一行，上下对齐且不缩进
空语句必须用“/*empty*/;”显式强调
慎用异常，仅当可有效简化代码时使用
- new/delete (T *pNewObj = new T(); | if (pNewObj == NULL) | { |     ... | } |  | ... |  | /* 以下可简化为预定义宏：DEL_PTR(pNewObj) */ | if (pNewObj != NULL) | { |     delete pNewObj; |     pNewObj = NULL; | })
new创建失败返回NULL，禁止抛出异常
delete释放指针后强制置空
delete释放单个元素，delete[]释放元素数组
### 2.7 函数
- 原则
尽量使用C语法，避免“引用”等C++特性（增加函数适用范围）
非原生类型参数一般采用指针传递地址
传值参数必要时可用const修饰以禁止函数内部修改其值（传值参数本身改值就无效）
	- 函数应该通过返回值指示错误并在注释中明确说明其含义
	建议A：返回int值并通过非零值指示错误原因 (示例： | /*! 获取xxx数据，成功返回0，失败返回正整数，警告返回负整数 */ | int get_xxx_data( |     int  nInput   /*! 输入值 */, |     int *pnOutput /*! 返回值(OUT) */ | );)
	建议B：返回boolean值并通过OUT参数返回错误原因 (示例： | /*! 获取xxx数据，成功返回true，失败返回false */ | bool get_xxx_data( |     int  nInput   /* 输入值 */, |     int *pnOutput /* 返回值(OUT) */, |     int *pnError  /* 错误或警告代码(OUT) */ DEFAULT_PARAM_VALUE(NULL) | );)
	建议C：返回数据值并通过无效值指示错误和OUT参数返回错误原因 (示例： | /*! 获取xxx数据，成功返回有效计数，失败返回-1 */ | int get_xxx_count( |     int  nInput   /* 输入值 */, |     int *pnError  /* 错误或警告代码(OUT) */ DEFAULT_PARAM_VALUE(NULL) | );)
仅当可有效简化代码时才考虑抛出异常
仅当可有效简化代码时才考虑定义模板
- 命名
	- 名称
	一般为1~3个单词的动词短语
	全局函数：单词小写，下划线分隔 (示例：int a_global_function(int _nArg1);)
	静态函数：额外添加单下划线前缀_ (示例：int _a_static_function(int _nArg1);)
	- 参数
	在普通变量命名规则的基础上统一加单下划线前缀 (示例：int a_global_function(int _nArg1);)
- 布局
	- 声明 (/*! 普通函数注释 */ | char *normal_function_name( |     int _nArg1 /*! 参数注释  */, |     int _nArg2 /*! 参数注释  */ | ); |  | /*! 模板函数注释 */ | template<typename T> | int &template_function_name( |     T   *_pVar /*! 参数注释  */, |     int _nArg1 /*! 参数注释  */, |     int _nArg2 /*! 参数注释  */ | );)
	模板声明独占一行
	返回值与函数名同行，返回类型的指针（*）与引用（&）标识与函数名结合
	2个及以上参数时，每个参数独占一行
	- 实现 (/*! 普通函数注释 */ | int normal_function_name(int _nArg1, int _nArg2) | { |     ... | } |  |  | /*! 模板函数注释 */ | template<typename T>  | int template_function_name(T *_pVar, int _nArg1, int _nArg2) | { |     ... | })
	模板声明独占一行
	返回值、函数名与所有参数同行，返回类型的指针（*）与引用（&）标识与函数名结合
	函数体缩进一级，嵌套代码块依次缩进
- 注释
	- 定义部分 (/*! 无参数函数 */ | int func_without_arg(); |  | /*! 单参数函数A */ | int func_with_one_arg_A(int _nOneArg/*! 唯一参数 */); |  | /*! 单参数函数B */ | int func_with_one_arg_B( |     int _nOneArg /*! 唯一参数 */ | ); |  | /*! 多参数函数 */ | int func_with_two_args( |     int   _nFirstArg    /*! 第1个参数 */, |     char *_pszSecondArg /*! 第2个参数(OUT) */ | );)
	使用相同缩进的前导整行C注释语法/*...*/或/*!...*/
	2个及以上参数时，每个参数独占1行，后跟行尾注释，逗号位于行尾（若有）
	返回参数必须添加OUT说明
	- 实现部分 (/*! 函数说明 */ | int demo_function(int _nArg1, int _nArg2/*OUT*/) | { |     /** |      * 函数流程: |      * 1) 步骤1 |      * 2) 步骤2 |      * 3) 步骤3 |     **/ |  |     /* 步骤1 */ |     .... |  |     /* 步骤2 */ |     ... |  |     /* 步骤3 */ |     ... |  |     return 0; | })
	使用相同缩进的前导整行注释
	返回参数必须添加行内注释/*OUT*/
	函数体开头按顺序描述整体逻辑
	函数体内部按顺序以逻辑块方式给出分步逻辑并使用相同缩进的前导整行注释
- 其它
互不相关函数之间用空行分隔声明
一组相关函数之间连续声明或用空行分隔声明
各函数实现之间用空行分隔
### 2.8 类（class）
- 原则
类保护内部数据并提供操作数据的公开方法
数据一般非公开，公开方法提供外部接口，非公开方法实现内部逻辑
每个文件一般定义1个类，文件名与类名相同
单个文件若定义多个类，各类间应该紧密关联，文件名体现整体特性并以大写字母开头
- 命名
	- 类
	一般为1~3个单词的名词短语
	首字母大写+大小写分隔 (class StudentInfo | { | public: |     Student(); |     ~Student(); |  | public: |     const char *GetName(); |  | protected: |     int calcScore();  |  | protected: |     int  m_nCode; |     char m_szName[64]; |     int  m_nGrade; |     ... | };)
	不加任何类前缀（常见如T和C）
	- 方法
	一般为1~3个单词的动词短语
	公开方法：首字母大写+大小写分隔 (class StudentInfo | { | public: |     Student(); |     ~Student(); |  | public: |     const char *GetName(); |  | protected: |     int calcScore();  |  | protected: |     int  m_nCode; |     char m_szName[64]; |     int  m_nGrade; |     ... | };)
	保护或私有方法：首字母小写+大小写分隔 (class StudentInfo | { | public: |     Student(); |     ~Student(); |  | public: |     const char *GetName(); |  | protected: |     int calcScore();  |  | protected: |     int  m_nCode; |     char m_szName[64]; |     int  m_nGrade; |     ... | };)
	有统一的区分即可
	- 变量
	一般为1~3个单词的名词短语
	成员变量命名同普通变量，动态成员加前缀：m_，静态成员加前缀s_ (class StudentInfo | { | public: |     Student(); |     ~Student(); |  | public: |     const char *GetName(); |  | protected: |     int calcScore();  |  | protected: |     int  m_nCode; |     char m_szName[64]; |     int  m_nGrade; |     ... |     static int s_nCount; |     ... | };)
- 布局
	- 声明
	前向类声明（类定义之外）
	模板参数声明
	类声明与基类声明（共1行）
		- 友元（friend）：无需访问属性
		 友元类
		友元函数
		- 常量（const）或枚举（enum）：访问属性一般公开，非公开可在实现文件中定义
		常量
		枚举
		- 构造与析构：单独访问属性
		缺省构造方法
		参数构造方法
		拷贝构造方法
		析构方法
		- 操作符重载：单独访问属性
		按操作符优先级顺序
		- 动态方法
			- 公开方法
			重定义（override）方法
			普通与重载（overload）方法
			- 保护方法
			重定义（override）方法
			普通与重载（overload）方法
			- 私有方法
			重定义（override）方法
			普通与重载（overload）方法
		- 静态方法
		公开方法
		保护方法
		私有方法
		- 动态成员
		公开成员
		保护成员
		私有成员
		- 静态成员
		公开成员
		保护成员
		私有成员
	友元函数（类定义之外）
	- 实现
	静态成员在类实现开头初始化
	方法实现按声明顺序排列
	所有动态成员变量和成员函数强制用“this->”修饰
	所有静态成员变量和成员函数强制用“类名::”修饰
	构造方法的初始化列表模板 (BaseClass::BaseClass(int _nInitValue1, int _nInitValue2, int _nInitValue3) |     : m_nMember1(_nInitValue1) |     , m_nMember2(_nInitValue2) |     , m_nMember3(_nInitValue3) | { |     ... | } |  | DerivedClass::DerivedClass(int _nBaseArg, int _nInitValue1, int _nInitValue2, int _nInitValue3) |     : BaseClass(_nBaseArg) |     , m_nMember1(_nInitValue1) |     , m_nMember2(_nInitValue2) |     , m_nMember3(_nInitValue3) | { |     ... | })
- 注释
类应该提供前导专用注释 (//////////////////////////////////////////////////////////////////////////////// -> 80列，突出类定义 | // class Logger |  | /** |  * @class Logger |  * @brief 日志记录器 | **/ | class Logger | { | public: | 	... | protected: | 	... | };)
成员方法注释请参考普通函数
成员变量注释请参考普通变量
- 其它
类声明的大括号{}各自独占一行，上下对齐且不缩进
互不相关方法之间用空行分隔
一组相关方法之间连续声明或用空行分隔
各方法实现之间用空行分隔
访问属性（public, protected, private）均独占一行并不缩进
类方法尽量避免使用异常，仅当可有效简化代码时才考虑抛出异常
类设计尽量避免使用模板，仅当可有效简化代码时才考虑定义模板
### 2.9 空间（namespace） (namespace x { |  | x的实体代码 |  | namespace y { |  | y的实体代码 |  | }/* namespace x.y */ |  | }/* namespace x */ |  | ==== |  | namespace x { namespace y { |  | y的实体代码（无x的实体代码时） |  | }/* namespace x.y */ }/* namespace x */)
- 命名
一般为1~3个单词的名词短语
单词大写+下划线分隔 (示例：STORAGE_SERVICE)
- 布局
namespace关键字+名称+起始大括号“{”共同独占一行（共1行）
命名空间的结束大括号“}”独占一行且不缩进
命名空间内部的实体代码不缩进
命名空间仅在必要时才考虑嵌套
### 2.10 模板（template） (template<typename T> | ... |  | template<typename X, typename Y, typename Z> | ...)
推荐使用C++标准模板库（STL）
实际编程中自有代码慎用模板实现
### 2.11 注释
整行注释与被注释对象相同缩进，前面必须空行前导 (（空行） | /* 整行注释 */ | ...)
行内注释的前后和内部首尾无空格 (float fDiameter/*直径*/ = 2 * PI/*圆周率*/ * fRadius/*半径*/;)
行尾注释的前面和内部首尾有空格 (float fDiameter = 2 * PI * fRadius;（空格）/*（空格）圆周长的计算公式（空格）*/ | 或 | float fDiameter = 2 * PI * fRadius;（空格）//（空格）圆周长的计算公式)
整行注释说明后续多个代码块，直至遇到新的整行注释 (/* 本注释说明以下2个代码块 */ | int nSum = 0; |  | for (int i = 0; i < N; i ++) | { |     ... | } |  | /* 本注释说明以下1个代码块 */ | while (a > b) | { |     ... | })
整行注释说明已包含多个整行注释的组合代码块时，行尾加类似>>>标识并追加空行 (/* 本注释说明以下3个代码块 >>> */ |  | /* 本注释说明以下2个代码块 */ | int nSum = 0; |  | for (int i = 0; i < N; i ++) | { |     ... | } |  | /* 本注释说明以下1个代码块 */ | while (a > b) | { |     ... | })
### 2.12 空白
- 缩进
每级缩进统一为4个空格，不允许使用TAB符
- 空格
操作符两侧应该添加单个空格
函数名和参数列表之间不得出现空格
小括号()和中括号[]内侧不得出现空格
除上下对齐时，不得出现2个及以上连续空格
逗号“,”和分号“;”表达式中，空格仅出现后面，不出现在前面
- 空行
	- 单个空行用于分隔各种代码块
	#include块前后
	类定义前后
	函数体前后
	结构体与联合体前后
2个空行用于突出分隔效果（建议用前后各有1个空行的连续字符的整行注释替代） (代码A | （空行） | （空行） | 代码B |  | 代码A | （空行） | //////////////////////////////////////// | （空行） | 代码B)
不得存在3个及以上连续空行
“{”后和“}”前不得有空行
- 文件
文件开头有且仅有1个空行
文件末尾有且仅有1个空行
每行末尾必须删除空白字符
## 3 最佳实践
### 3.1 命名规则
使用英文单词命名，单词数量1~3为宜，单词长度相近为宜，超出时注意控制总长度
英文单词缩写优先顺序：1）常用缩写；2）前N个字符；3）类似i18n缩写
- 英文单词缩写一般情况禁止去元音缩写
解释：请大家猜猜cd是什么含义？
避免使用汉语拼音，尤其是首字母缩写（大家熟知的拼音缩写除外）
关联名称尽量使用类似的结构和长度（相同长度的名称通过对齐易于发现拼写错误）
### 3.2 代码注释
注释的比例应该根据需要灵活确定，注释行数建议控制在总行数的20%~50%
注释应该描述代码本身无法传递的信息，尽量避免对代码的机械翻译
注释应该提高代码可读性，充分利用注释行及其颜色来划分代码块，描述代码逻辑关系
### 3.3 代码缩进
大括号{}本身不缩进
除namespace内容和switch的case分支不缩进外，其它大括号{}包围的内容均缩进一级
### 3.4 长行拆分
每行长度一般不超过120字符
过长代码折行时从低优先级位置断开
过长代码折行时，连接操作符统一放在首部或尾部（如：+-*/可放首部，,;可放尾部）
首个拆行（第2行）与第1行保持一定缩进（可锚定等号和左括号等特定位置）
后续拆行（第3行及以后）与第2行对齐
### 3.5 利用对称
相似代码块应充分利用对称原则，包括命名长度的一致和代码结构的一致，这样通过对比常可有效发现拼写和复制错误
